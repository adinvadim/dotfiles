#!/usr/bin/env bash
set -euo pipefail

# --- Config (flags > env > defaults) ---
PG_USER="${PGUSER:-$(whoami)}"
PG_HOST="${PGHOST:-localhost}"
PG_PORT="${PGPORT:-5432}"
REDIS_HOST="${DB_REDIS_HOST:-localhost}"
REDIS_PORT="${DB_REDIS_PORT:-6379}"

# --- Global flags ---
JSON=0
FORCE=0
USE_COLOR=1

# Respect NO_COLOR convention
[[ -n "${NO_COLOR:-}" ]] && USE_COLOR=0

# --- Color helpers (stderr only) ---
_color() { [[ "$USE_COLOR" -eq 1 ]] && [[ -t 2 ]]; }

red()   { _color && printf '\033[31m%s\033[0m' "$*" || printf '%s' "$*"; }
green() { _color && printf '\033[32m%s\033[0m' "$*" || printf '%s' "$*"; }
dim()   { _color && printf '\033[2m%s\033[0m' "$*" || printf '%s' "$*"; }
bold()  { _color && printf '\033[1m%s\033[0m' "$*" || printf '%s' "$*"; }

info() { printf '%s %s\n' "$(green '✓')" "$*" >&2; }
warn() { printf '%s %s\n' "$(red '!')" "$*" >&2; }
die()  { printf '%s %s\n' "$(red '✗')" "$*" >&2; exit 1; }

# --- Helpers ---

# Infer database name from PWD (matches tat convention)
infer_name() {
  basename "$PWD" | tr '[:upper:]' '[:lower:]' | tr '.-' '_'
}

resolve_name() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    name="$(infer_name)"
  fi
  echo "$name"
}

db_url() {
  local name="$1"
  echo "postgresql://${PG_USER}@${PG_HOST}:${PG_PORT}/${name}"
}

tableplus_open_pg() {
  # TablePlus deeplink uses the DB URL scheme (postgresql://...) plus query params.
  # Docs: right-click connection in TablePlus -> "Copy as URL" for reference.
  local name="$1"
  local url
  url="$(db_url "$name")"
  url="${url}?statusColor=007F3D&env=local&name=${name}"
  open -a TablePlus "$url"
}

pg_running() {
  pg_isready -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" >/dev/null 2>&1
}

redis_running() {
  redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" ping >/dev/null 2>&1
}

db_exists() {
  psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc \
    "SELECT 1 FROM pg_database WHERE datname = '$1'" postgres 2>/dev/null | grep -q 1
}

pg_db_rows() {
  # Tab-separated: name \t size \t connections (for fzf / numbered menu)
  psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "
    SELECT d.datname
      || E'\t' || pg_size_pretty(pg_database_size(d.datname))
      || E'\t' || (SELECT count(*) FROM pg_stat_activity WHERE datname = d.datname)
    FROM pg_database d
    WHERE d.datistemplate = false AND d.datname != 'postgres'
    ORDER BY d.datname
  " postgres 2>/dev/null
}

choose_db_interactive() {
  local prompt="${1:-Select database}"

  local -a rows=()
  local line
  while IFS= read -r line; do
    [[ -n "$line" ]] && rows+=("$line")
  done < <(pg_db_rows)

  ((${#rows[@]} > 0)) || die "No databases found"

  if ! [[ -t 0 ]]; then
    die "Database name required in non-interactive mode"
  fi

  if command -v fzf >/dev/null 2>&1; then
    local selected
    selected="$(
      printf '%s\n' "${rows[@]}" |
        fzf --prompt="${prompt}> " --height=40% --reverse --delimiter=$'\t' --with-nth=1,2,3
    )" || return 1
    printf '%s\n' "${selected%%$'\t'*}"
    return 0
  fi

  printf '%s\n' "$(bold "$prompt:")" >&2
  local i
  printf '  %-20s %-10s %s\n' "NAME" "SIZE" "CONNS" >&2
  for i in "${!rows[@]}"; do
    local name size conns
    IFS=$'\t' read -r name size conns <<<"${rows[$i]}"
    printf '  %2d) %-20s %-10s %s\n' "$((i + 1))" "$name" "$size" "$conns" >&2
  done
  printf 'Enter name or number (blank to cancel): ' >&2

  local reply
  read -r reply
  [[ -z "$reply" ]] && exit 0

  if [[ "$reply" =~ ^[0-9]+$ ]]; then
    local idx=$((reply - 1))
    (( idx >= 0 && idx < ${#rows[@]} )) || die "Invalid selection"
    printf '%s\n' "${rows[$idx]%%$'\t'*}"
    return 0
  fi

  printf '%s\n' "$reply"
}

confirm() {
  local prompt="$1"
  if [[ "$FORCE" -eq 1 ]]; then
    return 0
  fi
  if [[ ! -t 0 ]]; then
    die "use --force for non-interactive"
  fi
  printf '%s ' "$prompt" >&2
  local reply
  read -r reply
  [[ "$reply" =~ ^[Yy]$ ]]
}

# --- Usage ---
usage() {
  cat <<'EOF'
db — Manage local PostgreSQL databases and Redis for multi-project development.

Usage:
  db <command> [name] [flags]
  db                          Show all databases (= db list)
  db <command> -h             Help for command

Commands:
  create, c, new    Create database, print connection info
  drop, rm          Drop database
  list, ls          List all databases with sizes
  url, u            Print DATABASE_URL (pipe-friendly)
  env, e            Print .env block
  clone, cp         Clone database via createdb -T
  reset             Drop + recreate database
  redis, r          Redis connection info + ping + memory
  info, i           PG + Redis status overview
  open, o           Open in TablePlus (pick db if omitted; use: db open --app)
  psql, sh          Open psql/pgcli shell
  setup             Install/start PG + Redis via brew

Flags:
  -h, --help        Show help
  -j, --json        JSON output
  -f, --force       Skip confirmations
      --no-color    Disable colored output
EOF
  exit 0
}

# --- Subcommands ---

cmd_create() {
  local name
  name="$(resolve_name "${1:-}")"
  pg_running || die "PostgreSQL is not running (try: db setup)"

  if db_exists "$name"; then
    warn "Database \"$name\" already exists"
  else
    createdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
    info "Created database \"$name\""
  fi

  local url
  url="$(db_url "$name")"

  echo ""
  echo "DATABASE_URL=${url}"
  echo ""
  echo "# .env"
  echo "PGHOST=${PG_HOST}"
  echo "PGPORT=${PG_PORT}"
  echo "PGUSER=${PG_USER}"
  echo "PGDATABASE=${name}"
  echo ""
  printf '%s\n' "$(dim "tip: auto-load with direnv:")" >&2
  printf '%s\n' "$(dim "  echo 'export DATABASE_URL=${url}' > .envrc && direnv allow")" >&2
}

cmd_drop() {
  local name
  name="$(resolve_name "${1:-}")"
  pg_running || die "PostgreSQL is not running"
  db_exists "$name" || die "Database \"$name\" does not exist"

  confirm "Drop database \"$name\"? [y/N]" || exit 0

  dropdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
  info "Dropped database \"$name\""
}

cmd_list() {
  pg_running || die "PostgreSQL is not running (try: db setup)"

  if [[ "$JSON" -eq 1 ]]; then
    psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "
      SELECT json_agg(row_to_json(t)) FROM (
        SELECT d.datname AS name,
               pg_size_pretty(pg_database_size(d.datname)) AS size,
               pg_database_size(d.datname) AS size_bytes,
               (SELECT count(*) FROM pg_stat_activity WHERE datname = d.datname) AS connections
        FROM pg_database d
        WHERE d.datistemplate = false AND d.datname != 'postgres'
        ORDER BY d.datname
      ) t
    " postgres
  else
    printf '%-20s %-12s %s\n' "NAME" "SIZE" "CONNS" >&2
    psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "
      SELECT d.datname,
             pg_size_pretty(pg_database_size(d.datname)),
             (SELECT count(*) FROM pg_stat_activity WHERE datname = d.datname)
      FROM pg_database d
      WHERE d.datistemplate = false AND d.datname != 'postgres'
      ORDER BY d.datname
    " postgres | while IFS='|' read -r name size conns; do
      printf '%-20s %-12s %s\n' "$name" "$size" "$conns"
    done
  fi
}

cmd_url() {
  local name
  name="$(resolve_name "${1:-}")"
  db_url "$name"
}

cmd_env() {
  local name
  name="$(resolve_name "${1:-}")"
  local url
  url="$(db_url "$name")"
  echo "DATABASE_URL=${url}"
  echo "PGHOST=${PG_HOST}"
  echo "PGPORT=${PG_PORT}"
  echo "PGUSER=${PG_USER}"
  echo "PGDATABASE=${name}"
}

cmd_clone() {
  local src="${1:-}"
  [[ -z "$src" ]] && die "Usage: db clone <src> [dst]"
  local dst="${2:-${src}_copy}"

  pg_running || die "PostgreSQL is not running"
  db_exists "$src" || die "Database \"$src\" does not exist"

  if db_exists "$dst"; then
    die "Database \"$dst\" already exists"
  fi

  if ! createdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -T "$src" "$dst" 2>/dev/null; then
    warn "createdb -T failed (likely active connections on \"$src\")"
    die "Try: pg_dump $src | psql $dst"
  fi
  info "Cloned \"$src\" → \"$dst\""
}

cmd_reset() {
  local name
  name="$(resolve_name "${1:-}")"
  pg_running || die "PostgreSQL is not running"
  db_exists "$name" || die "Database \"$name\" does not exist"

  confirm "Reset database \"$name\"? This will delete all data. [y/N]" || exit 0

  dropdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
  createdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
  info "Reset database \"$name\""
}

cmd_redis() {
  if ! redis_running; then
    die "Redis is not running on ${REDIS_HOST}:${REDIS_PORT} (try: db setup)"
  fi
  info "Redis running on ${REDIS_HOST}:${REDIS_PORT}"
  echo ""
  echo "REDIS_URL=redis://${REDIS_HOST}:${REDIS_PORT}"

  local mem keys
  mem=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '[:space:]')
  keys=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" dbsize 2>/dev/null | grep -oE '[0-9]+')
  echo ""
  echo "Memory: ${mem:-unknown}"
  echo "Keys:   ${keys:-0}"
}

cmd_info() {
  # PostgreSQL
  if pg_running; then
    local pg_version
    pg_version=$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "SHOW server_version" postgres 2>/dev/null || echo "unknown")
    local db_count
    db_count=$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc \
      "SELECT count(*) FROM pg_database WHERE datistemplate = false AND datname != 'postgres'" postgres 2>/dev/null || echo "?")
    local data_dir
    data_dir=$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "SHOW data_directory" postgres 2>/dev/null || echo "unknown")
    printf '%s %s\n' "$(green "PostgreSQL ${pg_version} ✓ running")" "" >&2
    printf '  Host:      %s:%s\n' "$PG_HOST" "$PG_PORT" >&2
    printf '  User:      %s\n' "$PG_USER" >&2
    printf '  Databases: %s\n' "$db_count" >&2
    printf '  Data:      %s\n' "$data_dir" >&2
  else
    printf '%s\n' "$(red 'PostgreSQL ✗ stopped')" >&2
    printf '  %s\n' "$(dim 'Run: db setup')" >&2
  fi

  echo "" >&2

  # Redis
  if redis_running; then
    local redis_version
    redis_version=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info server 2>/dev/null | grep redis_version | cut -d: -f2 | tr -d '[:space:]')
    local mem
    mem=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '[:space:]')
    local keys
    keys=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" dbsize 2>/dev/null | grep -oE '[0-9]+')
    printf '%s\n' "$(green "Redis ${redis_version:-?} ✓ running")" >&2
    printf '  Host:   %s:%s\n' "$REDIS_HOST" "$REDIS_PORT" >&2
    printf '  Memory: %s\n' "${mem:-unknown}" >&2
    printf '  Keys:   %s\n' "${keys:-0}" >&2
  else
    printf '%s\n' "$(red 'Redis ✗ stopped')" >&2
    printf '  %s\n' "$(dim 'Run: db setup')" >&2
  fi
}

cmd_open() {
  local name="${1:-}"

  # Subcommand-only flag: keep quick access to the GUI without picking a DB.
  if [[ "$name" == "--app" ]]; then
    if [[ ! -d "/Applications/TablePlus.app" ]]; then
      die "TablePlus not found. Install: brew install --cask tableplus"
    fi
    open -a TablePlus
    return 0
  fi

  if [[ ! -d "/Applications/TablePlus.app" ]]; then
    die "TablePlus not found. Install: brew install --cask tableplus"
  fi

  if [[ -n "$name" ]]; then
    pg_running || die "PostgreSQL is not running (try: db setup)"
    tableplus_open_pg "$name"
  else
    pg_running || die "PostgreSQL is not running (try: db setup)"
    name="$(choose_db_interactive "db open")" || exit 0
    tableplus_open_pg "$name"
  fi
}

cmd_psql() {
  local name
  name="$(resolve_name "${1:-}")"
  shift 2>/dev/null || true

  # Consume -- separator if present
  [[ "${1:-}" == "--" ]] && shift

  pg_running || die "PostgreSQL is not running"

  if command -v pgcli >/dev/null 2>&1; then
    exec pgcli -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d "$name" "$@"
  else
    exec psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d "$name" "$@"
  fi
}

cmd_setup() {
  if ! command -v brew >/dev/null 2>&1; then
    die "Homebrew is required"
  fi

  # PostgreSQL
  if brew list postgresql@17 >/dev/null 2>&1; then
    info "postgresql@17 installed"
  else
    printf '%s\n' "$(dim 'Installing postgresql@17...')" >&2
    brew install postgresql@17
    info "postgresql@17 installed"
  fi

  # Redis
  if brew list redis >/dev/null 2>&1; then
    info "redis installed"
  else
    printf '%s\n' "$(dim 'Installing redis...')" >&2
    brew install redis
    info "redis installed"
  fi

  # Start services
  if pg_running; then
    info "postgresql@17 started"
  else
    brew services start postgresql@17
    info "postgresql@17 started"
  fi

  if redis_running; then
    info "redis started"
  else
    brew services start redis
    info "redis started"
  fi

  printf '\n  %s\n' "$(dim 'Ready! Try: db create myapp')" >&2
}

# --- Parse global flags ---
args=()
passthrough=0
extra_args=()

for arg in "$@"; do
  if [[ "$passthrough" -eq 1 ]]; then
    extra_args+=("$arg")
    continue
  fi
  case "$arg" in
    --)
      passthrough=1
      extra_args+=("$arg")
      ;;
    -h|--help)
      usage
      ;;
    -j|--json)
      JSON=1
      ;;
    -f|--force)
      FORCE=1
      ;;
    --no-color)
      USE_COLOR=0
      ;;
    *)
      args+=("$arg")
      ;;
  esac
done

# Reconstruct args with passthrough
set -- "${args[@]+"${args[@]}"}" "${extra_args[@]+"${extra_args[@]}"}"

# --- Dispatch ---
cmd="${1:-list}"
shift 2>/dev/null || true

case "$cmd" in
  create|c|new)   cmd_create "$@" ;;
  drop|rm)        cmd_drop "$@" ;;
  list|ls)        cmd_list "$@" ;;
  url|u)          cmd_url "$@" ;;
  env|e)          cmd_env "$@" ;;
  clone|cp)       cmd_clone "$@" ;;
  reset)          cmd_reset "$@" ;;
  redis|r)        cmd_redis "$@" ;;
  info|i)         cmd_info "$@" ;;
  open|o)         cmd_open "$@" ;;
  psql|sh)        cmd_psql "$@" ;;
  setup)          cmd_setup "$@" ;;
  *)
    printf 'Unknown command: %s\n' "$cmd" >&2
    printf 'Run "db --help" for usage.\n' >&2
    exit 2
    ;;
esac
