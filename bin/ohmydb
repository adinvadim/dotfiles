#!/usr/bin/env bash
set -euo pipefail

# --- Config (flags > env > defaults) ---
VERSION="0.2.0"

PG_USER="${PGUSER:-$(whoami)}"
PG_HOST="${PGHOST:-localhost}"
PG_PORT="${PGPORT:-5432}"
REDIS_HOST="${DB_REDIS_HOST:-localhost}"
REDIS_PORT="${DB_REDIS_PORT:-6379}"

# ClickHouse
CH_HOST="${OHMYDB_CH_HOST:-${CLICKHOUSE_HOST:-127.0.0.1}}"
CH_PORT="${OHMYDB_CH_PORT:-${CLICKHOUSE_PORT:-19000}}"
CH_HTTP_PORT="${OHMYDB_CH_HTTP_PORT:-${CLICKHOUSE_HTTP_PORT:-18123}}"
CH_USER="${OHMYDB_CH_USER:-${CLICKHOUSE_USER:-default}}"
CH_PASSWORD="${OHMYDB_CH_PASSWORD:-${CLICKHOUSE_PASSWORD:-}}"
CH_DATABASE="${OHMYDB_CH_DATABASE:-${CLICKHOUSE_DATABASE:-default}}"
CH_DATA_DIR="${OHMYDB_CH_DATA_DIR:-${HOME}/.local/share/ohmydb/clickhouse}"
CH_PID_FILE="${OHMYDB_CH_PID_FILE:-${HOME}/.local/state/ohmydb/clickhouse.pid}"
CH_LOG_FILE="${OHMYDB_CH_LOG_FILE:-${HOME}/.local/state/ohmydb/clickhouse.log}"
CH_ERROR_LOG_FILE="${OHMYDB_CH_ERROR_LOG_FILE:-${HOME}/.local/state/ohmydb/clickhouse.error.log}"

# MinIO (S3-compatible)
MINIO_HOST="${OHMYDB_MINIO_HOST:-${MINIO_HOST:-localhost}}"
MINIO_PORT="${OHMYDB_MINIO_PORT:-${MINIO_PORT:-9000}}"
MINIO_CONSOLE_PORT="${OHMYDB_MINIO_CONSOLE_PORT:-${MINIO_CONSOLE_PORT:-9001}}"
MINIO_BIND="${OHMYDB_MINIO_BIND:-127.0.0.1}"
MINIO_ROOT_USER="${OHMYDB_MINIO_ROOT_USER:-${MINIO_ROOT_USER:-minioadmin}}"
MINIO_ROOT_PASSWORD="${OHMYDB_MINIO_ROOT_PASSWORD:-${MINIO_ROOT_PASSWORD:-minioadmin}}"
MINIO_ALIAS="${OHMYDB_MINIO_ALIAS:-${MINIO_ALIAS:-ohmydb}}"
MINIO_DATA_DIR="${OHMYDB_MINIO_DATA_DIR:-${HOME}/.local/share/ohmydb/minio}"
MINIO_PID_FILE="${OHMYDB_MINIO_PID_FILE:-${HOME}/.local/state/ohmydb/minio.pid}"
MINIO_LOG_FILE="${OHMYDB_MINIO_LOG_FILE:-${HOME}/.local/state/ohmydb/minio.log}"

# --- Global flags ---
JSON=0
FORCE=0
NO_INPUT=0
USE_COLOR=1

# Respect NO_COLOR convention
[[ -n "${NO_COLOR:-}" ]] && USE_COLOR=0

# --- Color helpers ---
# Color only when stdout is a TTY to avoid leaking escape codes into pipes/redirects.
_color() { [[ "$USE_COLOR" -eq 1 ]] && [[ -t 1 ]]; }

red()   { _color && printf '\033[31m%s\033[0m' "$*" || printf '%s' "$*"; }
green() { _color && printf '\033[32m%s\033[0m' "$*" || printf '%s' "$*"; }
dim()   { _color && printf '\033[2m%s\033[0m' "$*" || printf '%s' "$*"; }
bold()  { _color && printf '\033[1m%s\033[0m' "$*" || printf '%s' "$*"; }

info() { printf '%s %s\n' "$(green '✓')" "$*" >&2; }
warn() { printf '%s %s\n' "$(red '!')" "$*" >&2; }
die()  { printf '%s %s\n' "$(red '✗')" "$*" >&2; exit 1; }

print_prefixed_lines() {
  local prefix="$1"
  local text="$2"
  while IFS= read -r line; do
    [[ -n "$line" ]] && printf '%s%s\n' "$prefix" "$line"
  done <<<"$text"
}

# --- Helpers ---

# Infer database name from PWD (matches tat convention)
infer_name() {
  basename "$PWD" | tr '[:upper:]' '[:lower:]' | tr '.-' '_'
}

resolve_name() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    name="$(infer_name)"
  fi
  echo "$name"
}

db_url() {
  local name="$1"
  echo "postgresql://${PG_USER}@${PG_HOST}:${PG_PORT}/${name}"
}

tableplus_open_pg() {
  # TablePlus deeplink uses the DB URL scheme (postgresql://...) plus query params.
  # Docs: right-click connection in TablePlus -> "Copy as URL" for reference.
  local name="$1"
  local url
  url="$(db_url "$name")"
  url="${url}?statusColor=007F3D&env=local&name=${name}"
  open -a TablePlus "$url"
}

tableplus_open_clickhouse() {
  local db_name="${1:-$CH_DATABASE}"
  local auth
  if [[ -n "$CH_PASSWORD" ]]; then
    auth="${CH_USER}:${CH_PASSWORD}@"
  else
    auth="${CH_USER}@"
  fi
  local url
  url="clickhouse://${auth}${CH_HOST}:${CH_PORT}/${db_name}"
  url="${url}?statusColor=0B74DE&env=local&name=clickhouse_${db_name}"
  open -a TablePlus "$url"
}

ensure_tableplus_installed() {
  [[ -d "/Applications/TablePlus.app" ]] || die "TablePlus not found. Install: brew install --cask tableplus"
}

pg_running() {
  pg_isready -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" >/dev/null 2>&1
}

redis_running() {
  redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" ping >/dev/null 2>&1
}

clickhouse_http_url() {
  echo "http://${CH_HOST}:${CH_HTTP_PORT}"
}

clickhouse_native_url() {
  echo "clickhouse://${CH_USER}@${CH_HOST}:${CH_PORT}/${CH_DATABASE}"
}

clickhouse_bin_path() {
  command -v clickhouse 2>/dev/null || true
}

clickhouse_installed() {
  [[ -n "$(clickhouse_bin_path)" ]]
}

clickhouse_unquarantine() {
  # Best-effort: remove Gatekeeper quarantine bit for the cask binary.
  local bin
  bin="$(clickhouse_bin_path)"
  [[ -z "$bin" ]] && return 1
  xattr -d com.apple.quarantine "$bin" >/dev/null 2>&1 || true
  local target
  target="$(readlink "$bin" 2>/dev/null || true)"
  [[ -n "$target" ]] && xattr -d com.apple.quarantine "$target" >/dev/null 2>&1 || true
  return 0
}

clickhouse_running() {
  if command -v curl >/dev/null 2>&1; then
    local ping_url
    ping_url="$(clickhouse_http_url)/ping"
    [[ "$(curl -fsS --max-time 0.8 "$ping_url" 2>/dev/null || true)" == "Ok." ]] && return 0
    [[ "$(curl -fsS --max-time 0.8 --user "${CH_USER}:${CH_PASSWORD}" "$ping_url" 2>/dev/null || true)" == "Ok." ]] && return 0
    return 1
  else
    return 1
  fi
}

clickhouse_query() {
  local sql="$1"
  command -v curl >/dev/null 2>&1 || return 1
  local url
  url="$(clickhouse_http_url)/?database=${CH_DATABASE}"
  curl -fsS --max-time 1.5 --data-binary "${sql} FORMAT TSVRaw" "$url" 2>/dev/null && return 0
  curl -fsS --max-time 1.5 --user "${CH_USER}:${CH_PASSWORD}" --data-binary "${sql} FORMAT TSVRaw" "$url" 2>/dev/null
}

clickhouse_db_names() {
  clickhouse_query "
    SELECT name
    FROM system.databases
    WHERE name NOT IN ('system', 'information_schema', 'INFORMATION_SCHEMA')
    ORDER BY name
  "
}

clickhouse_db_rows() {
  clickhouse_query "
    SELECT concat(d.name, '\t', toString(count(t.name)))
    FROM system.databases d
    LEFT JOIN system.tables t ON d.name = t.database
    WHERE d.name NOT IN ('system', 'information_schema', 'INFORMATION_SCHEMA')
    GROUP BY d.name
    ORDER BY d.name
  "
}

clickhouse_db_size_rows() {
  # TSV: name \t bytes \t pretty_size
  clickhouse_query "
    WITH sizes AS (
      SELECT database, sum(bytes_on_disk) AS bytes
      FROM system.parts
      WHERE active
      GROUP BY database
    )
    SELECT concat(
      d.name, '\t',
      toString(ifNull(s.bytes, 0)), '\t',
      formatReadableSize(ifNull(s.bytes, 0))
    )
    FROM system.databases d
    LEFT JOIN sizes s ON s.database = d.name
    WHERE d.name NOT IN ('system', 'information_schema', 'INFORMATION_SCHEMA')
    ORDER BY d.name
  "
}

clickhouse_start_local() {
  clickhouse_installed || die "clickhouse not installed. Install via: ohmydb setup"
  clickhouse_unquarantine || true

  if clickhouse_running; then
    return 0
  fi

  mkdir -p "$CH_DATA_DIR" "$(dirname "$CH_PID_FILE")" "$(dirname "$CH_LOG_FILE")"

  # Start self-contained local ClickHouse server with isolated data dir.
  clickhouse server --daemon -- \
    --path="$CH_DATA_DIR" \
    --http_port="$CH_HTTP_PORT" \
    --tcp_port="$CH_PORT" \
    --listen_host="$CH_HOST" \
    --logger.console=0 \
    --logger.log="$CH_LOG_FILE" \
    --logger.errorlog="$CH_ERROR_LOG_FILE" \
    --pidfile="$CH_PID_FILE" >/dev/null 2>&1 || return 1

  local i
  for i in {1..20}; do
    clickhouse_running && return 0
    sleep 0.2
  done

  warn "ClickHouse started but health endpoint not responding yet"
  return 0
}

minio_url() {
  echo "http://${MINIO_HOST}:${MINIO_PORT}"
}

minio_console_url() {
  echo "http://${MINIO_HOST}:${MINIO_CONSOLE_PORT}"
}

minio_running() {
  if command -v curl >/dev/null 2>&1; then
    curl -fsS --max-time 0.6 "$(minio_url)/minio/health/live" >/dev/null 2>&1
  else
    # Best-effort: if curl isn't available, assume stopped.
    return 1
  fi
}

mc_available() {
  command -v mc >/dev/null 2>&1
}

mc_ensure_alias() {
  mc_available || return 1
  # Always (re)set our alias to avoid partial/empty credentials in existing configs.
  mc alias set "$MINIO_ALIAS" "$(minio_url)" "$MINIO_ROOT_USER" "$MINIO_ROOT_PASSWORD" --api S3v4 >/dev/null 2>&1
}

minio_bucket_names() {
  mc_available || return 2
  mc_ensure_alias || return 1
  mc ls "$MINIO_ALIAS" 2>/dev/null | awk '{print $NF}' | sed 's:/*$::' | sed '/^$/d'
}

minio_start_local() {
  command -v minio >/dev/null 2>&1 || die "minio not found. Install: brew install minio"

  if minio_running; then
    return 0
  fi

  mkdir -p "$MINIO_DATA_DIR" "$(dirname "$MINIO_PID_FILE")" "$(dirname "$MINIO_LOG_FILE")"

  # Start MinIO as a background process (brew's service doesn't always exist / isn't configurable).
  # Bind to loopback by default to avoid exposing it on the network.
  MINIO_ROOT_USER="$MINIO_ROOT_USER" \
  MINIO_ROOT_PASSWORD="$MINIO_ROOT_PASSWORD" \
    nohup minio server "$MINIO_DATA_DIR" \
      --address "${MINIO_BIND}:${MINIO_PORT}" \
      --console-address "${MINIO_BIND}:${MINIO_CONSOLE_PORT}" \
      >"$MINIO_LOG_FILE" 2>&1 &

  echo "$!" >"$MINIO_PID_FILE"

  # Wait briefly for readiness.
  local i
  for i in {1..15}; do
    minio_running && return 0
    sleep 0.2
  done

  warn "MinIO started but health endpoint not responding yet"
  return 0
}

db_exists() {
  psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc \
    "SELECT 1 FROM pg_database WHERE datname = '$1'" postgres 2>/dev/null | grep -q 1
}

pg_db_rows() {
  # Tab-separated: name \t size \t connections (for fzf / numbered menu)
  psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "
    SELECT d.datname
      || E'\t' || pg_size_pretty(pg_database_size(d.datname))
      || E'\t' || (SELECT count(*) FROM pg_stat_activity WHERE datname = d.datname)
    FROM pg_database d
    WHERE d.datistemplate = false AND d.datname != 'postgres'
    ORDER BY d.datname
  " postgres 2>/dev/null
}

choose_tsv_row_interactive() {
  local prompt="$1"
  local header="$2"
  local with_nth="$3"
  shift 3
  local -a rows=("$@")

  ((${#rows[@]} > 0)) || die "No options found"

  if [[ "$NO_INPUT" -eq 1 ]]; then
    die "--no-input: explicit selection required"
  fi
  if ! [[ -t 0 ]]; then
    die "Selection required in non-interactive mode"
  fi

  if command -v fzf >/dev/null 2>&1; then
    local selected
    selected="$(
      printf '%s\n' "${rows[@]}" |
        fzf --prompt="${prompt}> " --height=40% --reverse --delimiter=$'\t' --with-nth="$with_nth"
    )" || return 1
    printf '%s\n' "$selected"
    return 0
  fi

  printf '%s\n' "$(bold "$prompt:")" >&2
  [[ -n "$header" ]] && printf '%s\n' "$header" >&2
  local i
  for i in "${!rows[@]}"; do
    printf '  %2d) %s\n' "$((i + 1))" "$(echo "${rows[$i]}" | tr '\t' ' ')" >&2
  done
  printf 'Enter number (blank to cancel): ' >&2

  local reply
  read -r reply
  [[ -z "$reply" ]] && exit 0
  [[ "$reply" =~ ^[0-9]+$ ]] || die "Please enter a number"

  local idx=$((reply - 1))
  (( idx >= 0 && idx < ${#rows[@]} )) || die "Invalid selection"
  printf '%s\n' "${rows[$idx]}"
}

choose_open_provider_interactive() {
  local pg_state ch_state
  pg_state="$(pg_running && echo running || echo stopped)"
  ch_state="$(clickhouse_running && echo running || echo stopped)"

  local -a rows=(
    "$(printf 'postgres\tPostgreSQL\t%s' "$pg_state")"
    "$(printf 'clickhouse\tClickHouse\t%s' "$ch_state")"
  )

  local selected
  selected="$(choose_tsv_row_interactive "ohmydb open" "  PROVIDER     ENGINE       STATUS" "1,2,3" "${rows[@]}")" || return 1
  local provider="${selected%%$'\t'*}"
  # Backstop for malformed rows that may contain literal '\t' sequences.
  provider="${provider%%\\t*}"
  printf '%s\n' "$provider"
}

provider_db_rows() {
  local provider="$1"
  case "$provider" in
    postgres)
      pg_db_rows
      ;;
    clickhouse)
      clickhouse_db_rows
      ;;
    *)
      return 1
      ;;
  esac
}

choose_provider_db_interactive() {
  local provider="$1"
  local prompt header with_nth
  case "$provider" in
    postgres)
      prompt="ohmydb open: postgres"
      header="  NAME                 SIZE       CONNS"
      with_nth="1,2,3"
      ;;
    clickhouse)
      prompt="ohmydb open: clickhouse"
      header="  NAME                 TABLES"
      with_nth="1,2"
      ;;
    *)
      die "Unknown provider: $provider"
      ;;
  esac

  local -a rows=()
  local line
  while IFS= read -r line; do
    [[ -n "$line" ]] && rows+=("$line")
  done < <(provider_db_rows "$provider")

  ((${#rows[@]} > 0)) || die "No databases found for provider \"$provider\""

  local selected
  selected="$(choose_tsv_row_interactive "$prompt" "$header" "$with_nth" "${rows[@]}")" || return 1
  printf '%s\n' "${selected%%$'\t'*}"
}

confirm() {
  local prompt="$1"
  if [[ "$FORCE" -eq 1 ]]; then
    return 0
  fi
  if [[ "$NO_INPUT" -eq 1 ]]; then
    die "--no-input: confirmation required (use --force to skip)"
  fi
  if [[ ! -t 0 ]]; then
    die "use --force for non-interactive"
  fi
  printf '%s ' "$prompt" >&2
  local reply
  read -r reply
  [[ "$reply" =~ ^[Yy]$ ]]
}

# --- Usage ---
usage() {
  cat <<'EOF'
ohmydb — Manage local PostgreSQL databases, Redis, ClickHouse, and MinIO for multi-project development.

Usage:
  ohmydb <command> [name] [flags]
  ohmydb                       Show PG databases + Redis + ClickHouse + MinIO buckets (= ohmydb list)
  ohmydb <command> -h          Help for command

Commands:
  create, c, new    Create database, print connection info
  drop, rm          Drop database
  list, ls          List PG databases + Redis + ClickHouse + MinIO
  url, u            Print DATABASE_URL (pipe-friendly)
  env, e            Print .env block
  clone, cp         Clone database via createdb -T
  reset             Drop + recreate database
  redis, r          Redis connection info + ping + memory
  clickhouse, ch    ClickHouse connection info + database list
  minio, m          MinIO connection info + bucket list
  info, i           PG + Redis + ClickHouse + MinIO status overview
  open, o           Open GUI (interactive provider/db picker; Postgres/ClickHouse in TablePlus)
  psql, sh          Open psql/pgcli shell
  setup             Install/start PG + Redis + ClickHouse via brew + start MinIO

Flags:
  -h, --help        Show help
      --version     Print version
  -j, --json        JSON output
  -f, --force       Skip confirmations
      --no-input    Disable prompts (requires explicit args)
      --no-color    Disable colored output
EOF
  exit 0
}

# --- Subcommands ---

cmd_create() {
  local name
  name="$(resolve_name "${1:-}")"
  pg_running || die "PostgreSQL is not running (try: ohmydb setup)"

  if db_exists "$name"; then
    warn "Database \"$name\" already exists"
  else
    createdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
    info "Created database \"$name\""
  fi

  local url
  url="$(db_url "$name")"

  echo ""
  echo "DATABASE_URL=${url}"
  echo ""
  echo "# .env"
  echo "PGHOST=${PG_HOST}"
  echo "PGPORT=${PG_PORT}"
  echo "PGUSER=${PG_USER}"
  echo "PGDATABASE=${name}"
  echo ""
  printf '%s\n' "$(dim "tip: auto-load with direnv:")" >&2
  printf '%s\n' "$(dim "  echo 'export DATABASE_URL=${url}' > .envrc && direnv allow")" >&2
}

cmd_drop() {
  local name
  name="$(resolve_name "${1:-}")"
  pg_running || die "PostgreSQL is not running"
  db_exists "$name" || die "Database \"$name\" does not exist"

  confirm "Drop database \"$name\"? [y/N]" || exit 0

  dropdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
  info "Dropped database \"$name\""
}

cmd_list() {
  if [[ "$JSON" -eq 1 ]]; then
    # Combined JSON contract (stable-ish):
    # { postgres: {...}, redis: {...}, clickhouse: {...}, minio: {...} }
    local pg_running_json redis_running_json clickhouse_running_json minio_running_json
    local pg_dbs_json redis_mem redis_keys clickhouse_dbs_json clickhouse_version minio_buckets_json
    local clickhouse_db_stats_json

    if pg_running; then
      pg_running_json=true
      pg_dbs_json="$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "
        SELECT coalesce(json_agg(row_to_json(t)), '[]'::json) FROM (
          SELECT d.datname AS name,
                 pg_size_pretty(pg_database_size(d.datname)) AS size,
                 pg_database_size(d.datname) AS size_bytes,
                 (SELECT count(*) FROM pg_stat_activity WHERE datname = d.datname) AS connections
          FROM pg_database d
          WHERE d.datistemplate = false AND d.datname != 'postgres'
          ORDER BY d.datname
        ) t
      " postgres 2>/dev/null || echo "[]")"
    else
      pg_running_json=false
      pg_dbs_json="[]"
    fi

    if redis_running; then
      redis_running_json=true
      redis_mem="$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '[:space:]' || true)"
      redis_keys="$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" dbsize 2>/dev/null | grep -oE '[0-9]+' || true)"
    else
      redis_running_json=false
      redis_mem=""
      redis_keys=""
    fi

    if clickhouse_running; then
      clickhouse_running_json=true
      if clickhouse_stats="$(clickhouse_db_size_rows 2>/dev/null)"; then
        clickhouse_dbs_json="$(printf '%s\n' "$clickhouse_stats" | awk -F '\t' '
          BEGIN { printf "["; n = 0 }
          NF {
            gsub(/"/, "\\\"", $1)
            printf "%s\"%s\"", (n++ ? "," : ""), $1
          }
          END { printf "]" }
        ')"
        clickhouse_db_stats_json="$(printf '%s\n' "$clickhouse_stats" | awk -F '\t' '
          BEGIN { printf "["; n = 0 }
          NF {
            gsub(/"/, "\\\"", $1)
            gsub(/"/, "\\\"", $3)
            printf "%s{\"name\":\"%s\",\"size\":\"%s\",\"size_bytes\":%s}", (n++ ? "," : ""), $1, $3, $2
          }
          END { printf "]" }
        ')"
      else
        clickhouse_dbs_json="[]"
        clickhouse_db_stats_json="[]"
      fi
      clickhouse_version="$(clickhouse_query "SELECT version()" 2>/dev/null | head -n1 || true)"
    else
      clickhouse_running_json=false
      clickhouse_dbs_json="[]"
      clickhouse_version=""
      clickhouse_db_stats_json="[]"
    fi

    if minio_running; then
      minio_running_json=true
      if buckets="$(minio_bucket_names 2>/dev/null)"; then
        minio_buckets_json="$(printf '%s\n' "$buckets" | awk 'BEGIN{print "["} {printf "%s\"%s\"", (NR>1?",":""), $0} END{print "]"}')"
      else
        minio_buckets_json="[]"
      fi
    else
      minio_running_json=false
      minio_buckets_json="[]"
    fi

    # Minimal JSON escaping for string values we control (host/user).
    printf '{'
    printf '"postgres":{"running":%s,"host":"%s","port":%s,"user":"%s","databases":%s},' \
      "$pg_running_json" "$PG_HOST" "$PG_PORT" "$PG_USER" "$pg_dbs_json"
    printf '"redis":{"running":%s,"host":"%s","port":%s,"memory":"%s","keys":"%s"},' \
      "$redis_running_json" "$REDIS_HOST" "$REDIS_PORT" "$redis_mem" "$redis_keys"
    printf '"clickhouse":{"running":%s,"host":"%s","port":%s,"http_port":%s,"user":"%s","version":"%s","databases":%s,"databases_stats":%s},' \
      "$clickhouse_running_json" "$CH_HOST" "$CH_PORT" "$CH_HTTP_PORT" "$CH_USER" "$clickhouse_version" "$clickhouse_dbs_json" "$clickhouse_db_stats_json"
    printf '"minio":{"running":%s,"url":"%s","console_url":"%s","buckets":%s}' \
      "$minio_running_json" "$(minio_url)" "$(minio_console_url)" "$minio_buckets_json"
    printf '}\n'
  else
    cmd_list_plain
  fi
}

cmd_list_plain() {
  # PostgreSQL
  printf '%s\n' "$(bold "PostgreSQL")"
  if pg_running; then
    printf '%-20s %-12s %s\n' "NAME" "SIZE" "CONNS"
    psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "
      SELECT d.datname,
             pg_size_pretty(pg_database_size(d.datname)),
             (SELECT count(*) FROM pg_stat_activity WHERE datname = d.datname)
      FROM pg_database d
      WHERE d.datistemplate = false AND d.datname != 'postgres'
      ORDER BY d.datname
    " postgres 2>/dev/null | while IFS='|' read -r name size conns; do
      printf '%-20s %-12s %s\n' "$name" "$size" "$conns"
    done || true
  else
    printf '%s\n' "$(red 'PostgreSQL stopped')"
    printf '  %s\n' "$(dim 'Run: ohmydb setup')"
  fi

  echo ""

  # Redis
  printf '%s\n' "$(bold "Redis")"
  if redis_running; then
    printf 'Host:   %s:%s\n' "$REDIS_HOST" "$REDIS_PORT"
    printf 'URL:    %s\n' "redis://${REDIS_HOST}:${REDIS_PORT}"
    local mem keys
    mem=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '[:space:]' || true)
    keys=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" dbsize 2>/dev/null | grep -oE '[0-9]+' || true)
    printf 'Memory: %s\n' "${mem:-unknown}"
    printf 'Keys:   %s\n' "${keys:-0}"
  else
    printf '%s\n' "$(red 'Redis stopped')"
    printf '  %s\n' "$(dim 'Run: ohmydb setup')"
  fi

  echo ""

  # ClickHouse
  printf '%s\n' "$(bold "ClickHouse")"
  if clickhouse_running; then
    printf 'Host:      %s:%s\n' "$CH_HOST" "$CH_PORT"
    printf 'HTTP:      %s\n' "$(clickhouse_http_url)"
    printf 'Native:    %s\n' "$(clickhouse_native_url)"
    local ch_stats
    if ch_stats="$(clickhouse_db_size_rows 2>/dev/null)"; then
      if [[ -z "$ch_stats" ]]; then
        printf 'Databases: (none)\n'
      else
        printf 'Databases:\n'
        printf '  %-30s %s\n' "NAME" "SIZE"
        while IFS=$'\t' read -r name bytes size; do
          [[ -z "${name:-}" ]] && continue
          printf '  %-30s %s\n' "$name" "${size:-0B}"
        done <<<"$ch_stats"
      fi
    else
      printf '%s\n' "$(red 'Unable to list databases (check credentials)')"
      printf '  %s\n' "$(dim 'Env: OHMYDB_CH_USER / OHMYDB_CH_PASSWORD / OHMYDB_CH_DATABASE')"
    fi
  else
    printf '%s\n' "$(red 'ClickHouse stopped')"
    printf '  %s\n' "$(dim 'Run: ohmydb setup')"
  fi

  echo ""

  # MinIO
  printf '%s\n' "$(bold "MinIO")"
  if minio_running; then
    printf 'URL:        %s\n' "$(minio_url)"
    printf 'Console:    %s\n' "$(minio_console_url)"
    if ! mc_available; then
      printf '%s\n' "$(red 'mc (minio client) not installed')"
      printf '  %s\n' "$(dim 'Install: brew install minio-mc')"
    else
      local buckets
      if buckets="$(minio_bucket_names 2>/dev/null)"; then
        if [[ -z "$buckets" ]]; then
          printf 'Buckets:    (none)\n'
        else
          printf 'Buckets:\n'
          print_prefixed_lines "  " "$buckets"
        fi
      else
        printf '%s\n' "$(red 'Unable to list buckets (check credentials)')"
        printf '  %s\n' "$(dim 'Env: OHMYDB_MINIO_ROOT_USER / OHMYDB_MINIO_ROOT_PASSWORD')"
      fi
    fi
  else
    printf '%s\n' "$(red 'MinIO stopped')"
    printf '  %s\n' "$(dim 'Run: ohmydb setup')"
  fi
}

cmd_url() {
  local name
  name="$(resolve_name "${1:-}")"
  db_url "$name"
}

cmd_env() {
  local name
  name="$(resolve_name "${1:-}")"
  local url
  url="$(db_url "$name")"
  echo "DATABASE_URL=${url}"
  echo "PGHOST=${PG_HOST}"
  echo "PGPORT=${PG_PORT}"
  echo "PGUSER=${PG_USER}"
  echo "PGDATABASE=${name}"
  echo "REDIS_URL=redis://${REDIS_HOST}:${REDIS_PORT}"
  echo "CLICKHOUSE_HOST=${CH_HOST}"
  echo "CLICKHOUSE_PORT=${CH_PORT}"
  echo "CLICKHOUSE_HTTP_PORT=${CH_HTTP_PORT}"
  echo "CLICKHOUSE_USER=${CH_USER}"
  echo "CLICKHOUSE_PASSWORD=(set via OHMYDB_CH_PASSWORD)"
  echo "CLICKHOUSE_DATABASE=${CH_DATABASE}"
  echo "CLICKHOUSE_HTTP_URL=$(clickhouse_http_url)"
  echo "CLICKHOUSE_NATIVE_URL=$(clickhouse_native_url)"
  echo "MINIO_URL=$(minio_url)"
  echo "MINIO_CONSOLE_URL=$(minio_console_url)"
  echo "MINIO_ROOT_USER=${MINIO_ROOT_USER}"
  echo "MINIO_ROOT_PASSWORD=(set via OHMYDB_MINIO_ROOT_PASSWORD)"
}

cmd_clone() {
  local src="${1:-}"
  [[ -z "$src" ]] && die "Usage: ohmydb clone <src> [dst]"
  local dst="${2:-${src}_copy}"

  pg_running || die "PostgreSQL is not running"
  db_exists "$src" || die "Database \"$src\" does not exist"

  if db_exists "$dst"; then
    die "Database \"$dst\" already exists"
  fi

  if ! createdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -T "$src" "$dst" 2>/dev/null; then
    warn "createdb -T failed (likely active connections on \"$src\")"
    die "Try: pg_dump $src | psql $dst"
  fi
  info "Cloned \"$src\" → \"$dst\""
}

cmd_reset() {
  local name
  name="$(resolve_name "${1:-}")"
  pg_running || die "PostgreSQL is not running"
  db_exists "$name" || die "Database \"$name\" does not exist"

  confirm "Reset database \"$name\"? This will delete all data. [y/N]" || exit 0

  dropdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
  createdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
  info "Reset database \"$name\""
}

cmd_redis() {
  if ! redis_running; then
    die "Redis is not running on ${REDIS_HOST}:${REDIS_PORT} (try: ohmydb setup)"
  fi
  info "Redis running on ${REDIS_HOST}:${REDIS_PORT}"
  echo ""
  echo "REDIS_URL=redis://${REDIS_HOST}:${REDIS_PORT}"

  local mem keys
  mem=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '[:space:]')
  keys=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" dbsize 2>/dev/null | grep -oE '[0-9]+')
  echo ""
  echo "Memory: ${mem:-unknown}"
  echo "Keys:   ${keys:-0}"
}

cmd_clickhouse() {
  if ! clickhouse_running; then
    die "ClickHouse is not running on $(clickhouse_http_url) (try: ohmydb setup)"
  fi

  info "ClickHouse running"
  echo ""
  echo "CLICKHOUSE_HTTP_URL=$(clickhouse_http_url)"
  echo "CLICKHOUSE_NATIVE_URL=$(clickhouse_native_url)"
  echo "CLICKHOUSE_USER=${CH_USER}"
  echo "CLICKHOUSE_PASSWORD=(set via OHMYDB_CH_PASSWORD)"
  echo "CLICKHOUSE_DATABASE=${CH_DATABASE}"

  echo ""

  local dbs
  if dbs="$(clickhouse_db_size_rows 2>/dev/null)"; then
    if [[ -z "$dbs" ]]; then
      echo "Databases: (none)"
      return 0
    fi
    echo "Databases:"
    printf '  %-30s %s\n' "NAME" "SIZE"
    while IFS=$'\t' read -r name bytes size; do
      [[ -z "${name:-}" ]] && continue
      printf '  %-30s %s\n' "$name" "${size:-0B}"
    done <<<"$dbs"
  else
    warn "Unable to list databases (check credentials)"
    printf '%s\n' "$(dim 'Env: OHMYDB_CH_USER / OHMYDB_CH_PASSWORD / OHMYDB_CH_DATABASE')" >&2
  fi
}

cmd_minio() {
  if ! command -v minio >/dev/null 2>&1; then
    die "minio not found. Install: brew install minio"
  fi

  if ! minio_running; then
    die "MinIO is not running on $(minio_url) (try: ohmydb setup)"
  fi

  info "MinIO running"
  echo ""
  echo "MINIO_URL=$(minio_url)"
  echo "MINIO_CONSOLE_URL=$(minio_console_url)"
  echo "MINIO_ROOT_USER=${MINIO_ROOT_USER}"
  echo "MINIO_ROOT_PASSWORD=(set via OHMYDB_MINIO_ROOT_PASSWORD)"

  echo ""

  if ! mc_available; then
    warn "mc (minio client) not installed"
    printf '%s\n' "$(dim 'Install: brew install minio-mc')" >&2
    return 0
  fi

  local buckets
  if buckets="$(minio_bucket_names 2>/dev/null)"; then
    if [[ -z "$buckets" ]]; then
      echo "Buckets: (none)"
      return 0
    fi
    echo "Buckets:"
    print_prefixed_lines "  " "$buckets"
  else
    die "Unable to list buckets (check credentials: OHMYDB_MINIO_ROOT_USER/OHMYDB_MINIO_ROOT_PASSWORD)"
  fi
}

cmd_info() {
  # PostgreSQL
  if pg_running; then
    local pg_version
    pg_version=$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "SHOW server_version" postgres 2>/dev/null || echo "unknown")
    local db_count
    db_count=$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc \
      "SELECT count(*) FROM pg_database WHERE datistemplate = false AND datname != 'postgres'" postgres 2>/dev/null || echo "?")
    local data_dir
    data_dir=$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "SHOW data_directory" postgres 2>/dev/null || echo "unknown")
    printf '%s %s\n' "$(green "PostgreSQL ${pg_version} ✓ running")" "" >&2
    printf '  Host:      %s:%s\n' "$PG_HOST" "$PG_PORT" >&2
    printf '  User:      %s\n' "$PG_USER" >&2
    printf '  Databases: %s\n' "$db_count" >&2
    printf '  Data:      %s\n' "$data_dir" >&2
  else
    printf '%s\n' "$(red 'PostgreSQL ✗ stopped')" >&2
    printf '  %s\n' "$(dim 'Run: ohmydb setup')" >&2
  fi

  echo "" >&2

  # Redis
  if redis_running; then
    local redis_version
    redis_version=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info server 2>/dev/null | grep redis_version | cut -d: -f2 | tr -d '[:space:]')
    local mem
    mem=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '[:space:]')
    local keys
    keys=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" dbsize 2>/dev/null | grep -oE '[0-9]+')
    printf '%s\n' "$(green "Redis ${redis_version:-?} ✓ running")" >&2
    printf '  Host:   %s:%s\n' "$REDIS_HOST" "$REDIS_PORT" >&2
    printf '  Memory: %s\n' "${mem:-unknown}" >&2
    printf '  Keys:   %s\n' "${keys:-0}" >&2
  else
    printf '%s\n' "$(red 'Redis ✗ stopped')" >&2
    printf '  %s\n' "$(dim 'Run: ohmydb setup')" >&2
  fi

  echo "" >&2

  # ClickHouse
  if clickhouse_running; then
    local ch_version
    ch_version="$(clickhouse_query "SELECT version()" 2>/dev/null | head -n1 || true)"
    printf '%s\n' "$(green "ClickHouse ${ch_version:-?} ✓ running")" >&2
    printf '  Host:      %s:%s\n' "$CH_HOST" "$CH_PORT" >&2
    printf '  HTTP:      %s\n' "$(clickhouse_http_url)" >&2
    local ch_db_count
    if ch_db_count="$(clickhouse_db_names 2>/dev/null | wc -l | tr -d '[:space:]')"; then
      [[ -z "$ch_db_count" ]] && ch_db_count="0"
    else
      ch_db_count="?"
    fi
    printf '  Databases: %s\n' "$ch_db_count" >&2
  else
    printf '%s\n' "$(red 'ClickHouse ✗ stopped')" >&2
    printf '  %s\n' "$(dim 'Run: ohmydb setup')" >&2
  fi

  echo "" >&2

  # MinIO
  if minio_running; then
    printf '%s\n' "$(green "MinIO ✓ running")" >&2
    printf '  URL:     %s\n' "$(minio_url)" >&2
    printf '  Console: %s\n' "$(minio_console_url)" >&2
    if mc_available; then
      local bucket_count
      if bucket_count="$(minio_bucket_names 2>/dev/null | wc -l | tr -d '[:space:]')"; then
        [[ -z "$bucket_count" ]] && bucket_count="0"
      else
        bucket_count="?"
      fi
      printf '  Buckets: %s\n' "$bucket_count" >&2
    else
      printf '  %s\n' "$(dim 'Install client: brew install minio-mc')" >&2
    fi
  else
    printf '%s\n' "$(red 'MinIO ✗ stopped')" >&2
    printf '  %s\n' "$(dim 'Run: ohmydb setup')" >&2
  fi
}

cmd_open() {
  local name=""
  local target="auto"

  while (($# > 0)); do
    case "$1" in
      --clickhouse|--ch|clickhouse|ch)
        target="clickhouse"
        ;;
      --postgres|--pg|postgres|pg)
        target="postgres"
        ;;
      --app)
        target="app"
        ;;
      *)
        if [[ -z "$name" ]]; then
          name="$1"
        else
          die "Unexpected argument for open: $1"
        fi
        ;;
    esac
    shift
  done

  # Subcommand-only flag: keep quick access to the GUI without picking a DB.
  if [[ "$target" == "app" ]]; then
    [[ -n "$name" ]] && die "--app does not accept a database name"
    ensure_tableplus_installed
    open -a TablePlus
    return 0
  fi

  if [[ "$target" == "auto" ]]; then
    if [[ -n "$name" ]]; then
      # Backward compatibility: `ohmydb open <name>` still means PostgreSQL database.
      target="postgres"
    else
      target="$(choose_open_provider_interactive)" || exit 0
    fi
  fi

  ensure_tableplus_installed

  case "$target" in
    postgres)
      pg_running || die "PostgreSQL is not running (try: ohmydb setup)"
      if [[ -z "$name" ]]; then
        name="$(choose_provider_db_interactive postgres)" || exit 0
      fi
      tableplus_open_pg "$name"
      ;;
    clickhouse)
      clickhouse_running || die "ClickHouse is not running on $(clickhouse_http_url) (try: ohmydb setup)"
      if [[ -z "$name" ]]; then
        name="$(choose_provider_db_interactive clickhouse)" || exit 0
      fi
      tableplus_open_clickhouse "$name"
      ;;
    *)
      die "Unknown open target: $target"
      ;;
  esac
}

cmd_psql() {
  local name
  name="$(resolve_name "${1:-}")"
  shift 2>/dev/null || true

  # Consume -- separator if present
  [[ "${1:-}" == "--" ]] && shift

  pg_running || die "PostgreSQL is not running"

  if command -v pgcli >/dev/null 2>&1; then
    exec pgcli -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d "$name" "$@"
  else
    exec psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d "$name" "$@"
  fi
}

cmd_setup() {
  if ! command -v brew >/dev/null 2>&1; then
    die "Homebrew is required"
  fi

  # PostgreSQL
  if brew list postgresql@17 >/dev/null 2>&1; then
    info "postgresql@17 installed"
  else
    printf '%s\n' "$(dim 'Installing postgresql@17...')" >&2
    brew install postgresql@17
    info "postgresql@17 installed"
  fi

  # Redis
  if brew list redis >/dev/null 2>&1; then
    info "redis installed"
  else
    printf '%s\n' "$(dim 'Installing redis...')" >&2
    brew install redis
    info "redis installed"
  fi

  # ClickHouse (single binary via cask)
  if brew list --cask clickhouse >/dev/null 2>&1; then
    info "clickhouse installed"
  else
    printf '%s\n' "$(dim 'Installing clickhouse...')" >&2
    brew install --cask clickhouse
    info "clickhouse installed"
  fi
  clickhouse_unquarantine || true

  # MinIO
  if brew list minio >/dev/null 2>&1; then
    info "minio installed"
  else
    printf '%s\n' "$(dim 'Installing minio...')" >&2
    brew install minio
    info "minio installed"
  fi

  # MinIO client
  if brew list minio-mc >/dev/null 2>&1; then
    info "minio-mc installed"
  else
    printf '%s\n' "$(dim 'Installing minio-mc...')" >&2
    brew install minio-mc
    info "minio-mc installed"
  fi

  # Start services
  if pg_running; then
    info "postgresql@17 started"
  else
    brew services start postgresql@17
    info "postgresql@17 started"
  fi

  if redis_running; then
    info "redis started"
  else
    brew services start redis
    info "redis started"
  fi

  if clickhouse_running || clickhouse_start_local; then
    info "clickhouse started"
  else
    warn "clickhouse was not started automatically"
    printf '  %s\n' "$(dim 'Inspect logs: ~/.local/state/ohmydb/clickhouse.error.log')" >&2
  fi

  # MinIO: try brew service if present, otherwise start our own background process.
  if minio_running; then
    info "minio started"
  else
    brew services start minio >/dev/null 2>&1 || true
    minio_running || minio_start_local
    info "minio started"
  fi

  printf '\n  %s\n' "$(dim 'Ready! Try: ohmydb create myapp')" >&2
}

# --- Parse global flags ---
args=()
passthrough=0
extra_args=()

for arg in "$@"; do
  if [[ "$passthrough" -eq 1 ]]; then
    extra_args+=("$arg")
    continue
  fi
  case "$arg" in
    --)
      passthrough=1
      extra_args+=("$arg")
      ;;
    -h|--help)
      usage
      ;;
    --version)
      echo "$VERSION"
      exit 0
      ;;
    -j|--json)
      JSON=1
      ;;
    -f|--force)
      FORCE=1
      ;;
    --no-input)
      NO_INPUT=1
      ;;
    --no-color)
      USE_COLOR=0
      ;;
    *)
      args+=("$arg")
      ;;
  esac
done

# Reconstruct args with passthrough
set -- "${args[@]+"${args[@]}"}" "${extra_args[@]+"${extra_args[@]}"}"

# --- Dispatch ---
cmd="${1:-list}"
shift 2>/dev/null || true

case "$cmd" in
  create|c|new)   cmd_create "$@" ;;
  drop|rm)        cmd_drop "$@" ;;
  list|ls)        cmd_list "$@" ;;
  url|u)          cmd_url "$@" ;;
  env|e)          cmd_env "$@" ;;
  clone|cp)       cmd_clone "$@" ;;
  reset)          cmd_reset "$@" ;;
  redis|r)        cmd_redis "$@" ;;
  clickhouse|ch)  cmd_clickhouse "$@" ;;
  minio|m)        cmd_minio "$@" ;;
  info|i)         cmd_info "$@" ;;
  open|o)         cmd_open "$@" ;;
  psql|sh)        cmd_psql "$@" ;;
  setup)          cmd_setup "$@" ;;
  *)
    printf 'Unknown command: %s\n' "$cmd" >&2
    printf 'Run "ohmydb --help" for usage.\n' >&2
    exit 2
    ;;
esac
