#!/usr/bin/env bash
set -euo pipefail

# --- Config (flags > env > defaults) ---
VERSION="0.2.0"

PG_USER="${PGUSER:-$(whoami)}"
PG_HOST="${PGHOST:-localhost}"
PG_PORT="${PGPORT:-5432}"
REDIS_HOST="${DB_REDIS_HOST:-localhost}"
REDIS_PORT="${DB_REDIS_PORT:-6379}"

# MinIO (S3-compatible)
MINIO_HOST="${OHMYDB_MINIO_HOST:-${MINIO_HOST:-localhost}}"
MINIO_PORT="${OHMYDB_MINIO_PORT:-${MINIO_PORT:-9000}}"
MINIO_CONSOLE_PORT="${OHMYDB_MINIO_CONSOLE_PORT:-${MINIO_CONSOLE_PORT:-9001}}"
MINIO_BIND="${OHMYDB_MINIO_BIND:-127.0.0.1}"
MINIO_ROOT_USER="${OHMYDB_MINIO_ROOT_USER:-${MINIO_ROOT_USER:-minioadmin}}"
MINIO_ROOT_PASSWORD="${OHMYDB_MINIO_ROOT_PASSWORD:-${MINIO_ROOT_PASSWORD:-minioadmin}}"
MINIO_ALIAS="${OHMYDB_MINIO_ALIAS:-${MINIO_ALIAS:-ohmydb}}"
MINIO_DATA_DIR="${OHMYDB_MINIO_DATA_DIR:-${HOME}/.local/share/ohmydb/minio}"
MINIO_PID_FILE="${OHMYDB_MINIO_PID_FILE:-${HOME}/.local/state/ohmydb/minio.pid}"
MINIO_LOG_FILE="${OHMYDB_MINIO_LOG_FILE:-${HOME}/.local/state/ohmydb/minio.log}"

# --- Global flags ---
JSON=0
FORCE=0
NO_INPUT=0
USE_COLOR=1

# Respect NO_COLOR convention
[[ -n "${NO_COLOR:-}" ]] && USE_COLOR=0

# --- Color helpers ---
# Color only when stdout is a TTY to avoid leaking escape codes into pipes/redirects.
_color() { [[ "$USE_COLOR" -eq 1 ]] && [[ -t 1 ]]; }

red()   { _color && printf '\033[31m%s\033[0m' "$*" || printf '%s' "$*"; }
green() { _color && printf '\033[32m%s\033[0m' "$*" || printf '%s' "$*"; }
dim()   { _color && printf '\033[2m%s\033[0m' "$*" || printf '%s' "$*"; }
bold()  { _color && printf '\033[1m%s\033[0m' "$*" || printf '%s' "$*"; }

info() { printf '%s %s\n' "$(green '✓')" "$*" >&2; }
warn() { printf '%s %s\n' "$(red '!')" "$*" >&2; }
die()  { printf '%s %s\n' "$(red '✗')" "$*" >&2; exit 1; }

print_prefixed_lines() {
  local prefix="$1"
  local text="$2"
  while IFS= read -r line; do
    [[ -n "$line" ]] && printf '%s%s\n' "$prefix" "$line"
  done <<<"$text"
}

# --- Helpers ---

# Infer database name from PWD (matches tat convention)
infer_name() {
  basename "$PWD" | tr '[:upper:]' '[:lower:]' | tr '.-' '_'
}

resolve_name() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    name="$(infer_name)"
  fi
  echo "$name"
}

db_url() {
  local name="$1"
  echo "postgresql://${PG_USER}@${PG_HOST}:${PG_PORT}/${name}"
}

tableplus_open_pg() {
  # TablePlus deeplink uses the DB URL scheme (postgresql://...) plus query params.
  # Docs: right-click connection in TablePlus -> "Copy as URL" for reference.
  local name="$1"
  local url
  url="$(db_url "$name")"
  url="${url}?statusColor=007F3D&env=local&name=${name}"
  open -a TablePlus "$url"
}

pg_running() {
  pg_isready -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" >/dev/null 2>&1
}

redis_running() {
  redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" ping >/dev/null 2>&1
}

minio_url() {
  echo "http://${MINIO_HOST}:${MINIO_PORT}"
}

minio_console_url() {
  echo "http://${MINIO_HOST}:${MINIO_CONSOLE_PORT}"
}

minio_running() {
  if command -v curl >/dev/null 2>&1; then
    curl -fsS --max-time 0.6 "$(minio_url)/minio/health/live" >/dev/null 2>&1
  else
    # Best-effort: if curl isn't available, assume stopped.
    return 1
  fi
}

mc_available() {
  command -v mc >/dev/null 2>&1
}

mc_ensure_alias() {
  mc_available || return 1
  # Always (re)set our alias to avoid partial/empty credentials in existing configs.
  mc alias set "$MINIO_ALIAS" "$(minio_url)" "$MINIO_ROOT_USER" "$MINIO_ROOT_PASSWORD" --api S3v4 >/dev/null 2>&1
}

minio_bucket_names() {
  mc_available || return 2
  mc_ensure_alias || return 1
  mc ls "$MINIO_ALIAS" 2>/dev/null | awk '{print $NF}' | sed 's:/*$::' | sed '/^$/d'
}

minio_start_local() {
  command -v minio >/dev/null 2>&1 || die "minio not found. Install: brew install minio"

  if minio_running; then
    return 0
  fi

  mkdir -p "$MINIO_DATA_DIR" "$(dirname "$MINIO_PID_FILE")" "$(dirname "$MINIO_LOG_FILE")"

  # Start MinIO as a background process (brew's service doesn't always exist / isn't configurable).
  # Bind to loopback by default to avoid exposing it on the network.
  MINIO_ROOT_USER="$MINIO_ROOT_USER" \
  MINIO_ROOT_PASSWORD="$MINIO_ROOT_PASSWORD" \
    nohup minio server "$MINIO_DATA_DIR" \
      --address "${MINIO_BIND}:${MINIO_PORT}" \
      --console-address "${MINIO_BIND}:${MINIO_CONSOLE_PORT}" \
      >"$MINIO_LOG_FILE" 2>&1 &

  echo "$!" >"$MINIO_PID_FILE"

  # Wait briefly for readiness.
  local i
  for i in {1..15}; do
    minio_running && return 0
    sleep 0.2
  done

  warn "MinIO started but health endpoint not responding yet"
  return 0
}

db_exists() {
  psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc \
    "SELECT 1 FROM pg_database WHERE datname = '$1'" postgres 2>/dev/null | grep -q 1
}

pg_db_rows() {
  # Tab-separated: name \t size \t connections (for fzf / numbered menu)
  psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "
    SELECT d.datname
      || E'\t' || pg_size_pretty(pg_database_size(d.datname))
      || E'\t' || (SELECT count(*) FROM pg_stat_activity WHERE datname = d.datname)
    FROM pg_database d
    WHERE d.datistemplate = false AND d.datname != 'postgres'
    ORDER BY d.datname
  " postgres 2>/dev/null
}

choose_db_interactive() {
  local prompt="${1:-Select database}"

  local -a rows=()
  local line
  while IFS= read -r line; do
    [[ -n "$line" ]] && rows+=("$line")
  done < <(pg_db_rows)

  ((${#rows[@]} > 0)) || die "No databases found"

  if [[ "$NO_INPUT" -eq 1 ]]; then
    die "--no-input: database name required"
  fi
  if ! [[ -t 0 ]]; then
    die "Database name required in non-interactive mode"
  fi

  if command -v fzf >/dev/null 2>&1; then
    local selected
    selected="$(
      printf '%s\n' "${rows[@]}" |
        fzf --prompt="${prompt}> " --height=40% --reverse --delimiter=$'\t' --with-nth=1,2,3
    )" || return 1
    printf '%s\n' "${selected%%$'\t'*}"
    return 0
  fi

  printf '%s\n' "$(bold "$prompt:")" >&2
  local i
  printf '  %-20s %-10s %s\n' "NAME" "SIZE" "CONNS" >&2
  for i in "${!rows[@]}"; do
    local name size conns
    IFS=$'\t' read -r name size conns <<<"${rows[$i]}"
    printf '  %2d) %-20s %-10s %s\n' "$((i + 1))" "$name" "$size" "$conns" >&2
  done
  printf 'Enter name or number (blank to cancel): ' >&2

  local reply
  read -r reply
  [[ -z "$reply" ]] && exit 0

  if [[ "$reply" =~ ^[0-9]+$ ]]; then
    local idx=$((reply - 1))
    (( idx >= 0 && idx < ${#rows[@]} )) || die "Invalid selection"
    printf '%s\n' "${rows[$idx]%%$'\t'*}"
    return 0
  fi

  printf '%s\n' "$reply"
}

confirm() {
  local prompt="$1"
  if [[ "$FORCE" -eq 1 ]]; then
    return 0
  fi
  if [[ "$NO_INPUT" -eq 1 ]]; then
    die "--no-input: confirmation required (use --force to skip)"
  fi
  if [[ ! -t 0 ]]; then
    die "use --force for non-interactive"
  fi
  printf '%s ' "$prompt" >&2
  local reply
  read -r reply
  [[ "$reply" =~ ^[Yy]$ ]]
}

# --- Usage ---
usage() {
  cat <<'EOF'
ohmydb — Manage local PostgreSQL databases, Redis, and MinIO for multi-project development.

Usage:
  ohmydb <command> [name] [flags]
  ohmydb                       Show PG databases + Redis + MinIO buckets (= ohmydb list)
  ohmydb <command> -h          Help for command

Commands:
  create, c, new    Create database, print connection info
  drop, rm          Drop database
  list, ls          List PG databases + Redis + MinIO
  url, u            Print DATABASE_URL (pipe-friendly)
  env, e            Print .env block
  clone, cp         Clone database via createdb -T
  reset             Drop + recreate database
  redis, r          Redis connection info + ping + memory
  minio, m          MinIO connection info + bucket list
  info, i           PG + Redis + MinIO status overview
  open, o           Open in TablePlus (pick db if omitted; use: ohmydb open --app)
  psql, sh          Open psql/pgcli shell
  setup             Install/start PG + Redis via brew + start MinIO

Flags:
  -h, --help        Show help
      --version     Print version
  -j, --json        JSON output
  -f, --force       Skip confirmations
      --no-input    Disable prompts (requires explicit args)
      --no-color    Disable colored output
EOF
  exit 0
}

# --- Subcommands ---

cmd_create() {
  local name
  name="$(resolve_name "${1:-}")"
  pg_running || die "PostgreSQL is not running (try: ohmydb setup)"

  if db_exists "$name"; then
    warn "Database \"$name\" already exists"
  else
    createdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
    info "Created database \"$name\""
  fi

  local url
  url="$(db_url "$name")"

  echo ""
  echo "DATABASE_URL=${url}"
  echo ""
  echo "# .env"
  echo "PGHOST=${PG_HOST}"
  echo "PGPORT=${PG_PORT}"
  echo "PGUSER=${PG_USER}"
  echo "PGDATABASE=${name}"
  echo ""
  printf '%s\n' "$(dim "tip: auto-load with direnv:")" >&2
  printf '%s\n' "$(dim "  echo 'export DATABASE_URL=${url}' > .envrc && direnv allow")" >&2
}

cmd_drop() {
  local name
  name="$(resolve_name "${1:-}")"
  pg_running || die "PostgreSQL is not running"
  db_exists "$name" || die "Database \"$name\" does not exist"

  confirm "Drop database \"$name\"? [y/N]" || exit 0

  dropdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
  info "Dropped database \"$name\""
}

cmd_list() {
  if [[ "$JSON" -eq 1 ]]; then
    # Combined JSON contract (stable-ish):
    # { postgres: { running, host, port, user, databases: [...] }, redis: {...}, minio: {...} }
    local pg_running_json redis_running_json minio_running_json
    local pg_dbs_json redis_mem redis_keys minio_buckets_json

    if pg_running; then
      pg_running_json=true
      pg_dbs_json="$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "
        SELECT coalesce(json_agg(row_to_json(t)), '[]'::json) FROM (
          SELECT d.datname AS name,
                 pg_size_pretty(pg_database_size(d.datname)) AS size,
                 pg_database_size(d.datname) AS size_bytes,
                 (SELECT count(*) FROM pg_stat_activity WHERE datname = d.datname) AS connections
          FROM pg_database d
          WHERE d.datistemplate = false AND d.datname != 'postgres'
          ORDER BY d.datname
        ) t
      " postgres 2>/dev/null || echo "[]")"
    else
      pg_running_json=false
      pg_dbs_json="[]"
    fi

    if redis_running; then
      redis_running_json=true
      redis_mem="$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '[:space:]' || true)"
      redis_keys="$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" dbsize 2>/dev/null | grep -oE '[0-9]+' || true)"
    else
      redis_running_json=false
      redis_mem=""
      redis_keys=""
    fi

    if minio_running; then
      minio_running_json=true
      if buckets="$(minio_bucket_names 2>/dev/null)"; then
        minio_buckets_json="$(printf '%s\n' "$buckets" | awk 'BEGIN{print "["} {printf "%s\"%s\"", (NR>1?",":""), $0} END{print "]"}')"
      else
        minio_buckets_json="[]"
      fi
    else
      minio_running_json=false
      minio_buckets_json="[]"
    fi

    # Minimal JSON escaping for string values we control (host/user).
    printf '{'
    printf '"postgres":{"running":%s,"host":"%s","port":%s,"user":"%s","databases":%s},' \
      "$pg_running_json" "$PG_HOST" "$PG_PORT" "$PG_USER" "$pg_dbs_json"
    printf '"redis":{"running":%s,"host":"%s","port":%s,"memory":"%s","keys":"%s"},' \
      "$redis_running_json" "$REDIS_HOST" "$REDIS_PORT" "$redis_mem" "$redis_keys"
    printf '"minio":{"running":%s,"url":"%s","console_url":"%s","buckets":%s}' \
      "$minio_running_json" "$(minio_url)" "$(minio_console_url)" "$minio_buckets_json"
    printf '}\n'
  else
    cmd_list_plain
  fi
}

cmd_list_plain() {
  # PostgreSQL
  printf '%s\n' "$(bold "PostgreSQL")"
  if pg_running; then
    printf '%-20s %-12s %s\n' "NAME" "SIZE" "CONNS"
    psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "
      SELECT d.datname,
             pg_size_pretty(pg_database_size(d.datname)),
             (SELECT count(*) FROM pg_stat_activity WHERE datname = d.datname)
      FROM pg_database d
      WHERE d.datistemplate = false AND d.datname != 'postgres'
      ORDER BY d.datname
    " postgres 2>/dev/null | while IFS='|' read -r name size conns; do
      printf '%-20s %-12s %s\n' "$name" "$size" "$conns"
    done || true
  else
    printf '%s\n' "$(red 'PostgreSQL stopped')"
    printf '  %s\n' "$(dim 'Run: ohmydb setup')"
  fi

  echo ""

  # Redis
  printf '%s\n' "$(bold "Redis")"
  if redis_running; then
    printf 'Host:   %s:%s\n' "$REDIS_HOST" "$REDIS_PORT"
    printf 'URL:    %s\n' "redis://${REDIS_HOST}:${REDIS_PORT}"
    local mem keys
    mem=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '[:space:]' || true)
    keys=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" dbsize 2>/dev/null | grep -oE '[0-9]+' || true)
    printf 'Memory: %s\n' "${mem:-unknown}"
    printf 'Keys:   %s\n' "${keys:-0}"
  else
    printf '%s\n' "$(red 'Redis stopped')"
    printf '  %s\n' "$(dim 'Run: ohmydb setup')"
  fi

  echo ""

  # MinIO
  printf '%s\n' "$(bold "MinIO")"
  if minio_running; then
    printf 'URL:        %s\n' "$(minio_url)"
    printf 'Console:    %s\n' "$(minio_console_url)"
    if ! mc_available; then
      printf '%s\n' "$(red 'mc (minio client) not installed')"
      printf '  %s\n' "$(dim 'Install: brew install minio-mc')"
    else
      local buckets
      if buckets="$(minio_bucket_names 2>/dev/null)"; then
        if [[ -z "$buckets" ]]; then
          printf 'Buckets:    (none)\n'
        else
          printf 'Buckets:\n'
          print_prefixed_lines "  " "$buckets"
        fi
      else
        printf '%s\n' "$(red 'Unable to list buckets (check credentials)')"
        printf '  %s\n' "$(dim 'Env: OHMYDB_MINIO_ROOT_USER / OHMYDB_MINIO_ROOT_PASSWORD')"
      fi
    fi
  else
    printf '%s\n' "$(red 'MinIO stopped')"
    printf '  %s\n' "$(dim 'Run: ohmydb setup')"
  fi
}

cmd_url() {
  local name
  name="$(resolve_name "${1:-}")"
  db_url "$name"
}

cmd_env() {
  local name
  name="$(resolve_name "${1:-}")"
  local url
  url="$(db_url "$name")"
  echo "DATABASE_URL=${url}"
  echo "PGHOST=${PG_HOST}"
  echo "PGPORT=${PG_PORT}"
  echo "PGUSER=${PG_USER}"
  echo "PGDATABASE=${name}"
  echo "REDIS_URL=redis://${REDIS_HOST}:${REDIS_PORT}"
  echo "MINIO_URL=$(minio_url)"
  echo "MINIO_CONSOLE_URL=$(minio_console_url)"
  echo "MINIO_ROOT_USER=${MINIO_ROOT_USER}"
  echo "MINIO_ROOT_PASSWORD=(set via OHMYDB_MINIO_ROOT_PASSWORD)"
}

cmd_clone() {
  local src="${1:-}"
  [[ -z "$src" ]] && die "Usage: ohmydb clone <src> [dst]"
  local dst="${2:-${src}_copy}"

  pg_running || die "PostgreSQL is not running"
  db_exists "$src" || die "Database \"$src\" does not exist"

  if db_exists "$dst"; then
    die "Database \"$dst\" already exists"
  fi

  if ! createdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -T "$src" "$dst" 2>/dev/null; then
    warn "createdb -T failed (likely active connections on \"$src\")"
    die "Try: pg_dump $src | psql $dst"
  fi
  info "Cloned \"$src\" → \"$dst\""
}

cmd_reset() {
  local name
  name="$(resolve_name "${1:-}")"
  pg_running || die "PostgreSQL is not running"
  db_exists "$name" || die "Database \"$name\" does not exist"

  confirm "Reset database \"$name\"? This will delete all data. [y/N]" || exit 0

  dropdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
  createdb -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" "$name"
  info "Reset database \"$name\""
}

cmd_redis() {
  if ! redis_running; then
    die "Redis is not running on ${REDIS_HOST}:${REDIS_PORT} (try: ohmydb setup)"
  fi
  info "Redis running on ${REDIS_HOST}:${REDIS_PORT}"
  echo ""
  echo "REDIS_URL=redis://${REDIS_HOST}:${REDIS_PORT}"

  local mem keys
  mem=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '[:space:]')
  keys=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" dbsize 2>/dev/null | grep -oE '[0-9]+')
  echo ""
  echo "Memory: ${mem:-unknown}"
  echo "Keys:   ${keys:-0}"
}

cmd_minio() {
  if ! command -v minio >/dev/null 2>&1; then
    die "minio not found. Install: brew install minio"
  fi

  if ! minio_running; then
    die "MinIO is not running on $(minio_url) (try: ohmydb setup)"
  fi

  info "MinIO running"
  echo ""
  echo "MINIO_URL=$(minio_url)"
  echo "MINIO_CONSOLE_URL=$(minio_console_url)"
  echo "MINIO_ROOT_USER=${MINIO_ROOT_USER}"
  echo "MINIO_ROOT_PASSWORD=(set via OHMYDB_MINIO_ROOT_PASSWORD)"

  echo ""

  if ! mc_available; then
    warn "mc (minio client) not installed"
    printf '%s\n' "$(dim 'Install: brew install minio-mc')" >&2
    return 0
  fi

  local buckets
  if buckets="$(minio_bucket_names 2>/dev/null)"; then
    if [[ -z "$buckets" ]]; then
      echo "Buckets: (none)"
      return 0
    fi
    echo "Buckets:"
    print_prefixed_lines "  " "$buckets"
  else
    die "Unable to list buckets (check credentials: OHMYDB_MINIO_ROOT_USER/OHMYDB_MINIO_ROOT_PASSWORD)"
  fi
}

cmd_info() {
  # PostgreSQL
  if pg_running; then
    local pg_version
    pg_version=$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "SHOW server_version" postgres 2>/dev/null || echo "unknown")
    local db_count
    db_count=$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc \
      "SELECT count(*) FROM pg_database WHERE datistemplate = false AND datname != 'postgres'" postgres 2>/dev/null || echo "?")
    local data_dir
    data_dir=$(psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -Atc "SHOW data_directory" postgres 2>/dev/null || echo "unknown")
    printf '%s %s\n' "$(green "PostgreSQL ${pg_version} ✓ running")" "" >&2
    printf '  Host:      %s:%s\n' "$PG_HOST" "$PG_PORT" >&2
    printf '  User:      %s\n' "$PG_USER" >&2
    printf '  Databases: %s\n' "$db_count" >&2
    printf '  Data:      %s\n' "$data_dir" >&2
  else
    printf '%s\n' "$(red 'PostgreSQL ✗ stopped')" >&2
    printf '  %s\n' "$(dim 'Run: ohmydb setup')" >&2
  fi

  echo "" >&2

  # Redis
  if redis_running; then
    local redis_version
    redis_version=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info server 2>/dev/null | grep redis_version | cut -d: -f2 | tr -d '[:space:]')
    local mem
    mem=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" info memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '[:space:]')
    local keys
    keys=$(redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" dbsize 2>/dev/null | grep -oE '[0-9]+')
    printf '%s\n' "$(green "Redis ${redis_version:-?} ✓ running")" >&2
    printf '  Host:   %s:%s\n' "$REDIS_HOST" "$REDIS_PORT" >&2
    printf '  Memory: %s\n' "${mem:-unknown}" >&2
    printf '  Keys:   %s\n' "${keys:-0}" >&2
  else
    printf '%s\n' "$(red 'Redis ✗ stopped')" >&2
    printf '  %s\n' "$(dim 'Run: ohmydb setup')" >&2
  fi

  echo "" >&2

  # MinIO
  if minio_running; then
    printf '%s\n' "$(green "MinIO ✓ running")" >&2
    printf '  URL:     %s\n' "$(minio_url)" >&2
    printf '  Console: %s\n' "$(minio_console_url)" >&2
    if mc_available; then
      local bucket_count
      if bucket_count="$(minio_bucket_names 2>/dev/null | wc -l | tr -d '[:space:]')"; then
        [[ -z "$bucket_count" ]] && bucket_count="0"
      else
        bucket_count="?"
      fi
      printf '  Buckets: %s\n' "$bucket_count" >&2
    else
      printf '  %s\n' "$(dim 'Install client: brew install minio-mc')" >&2
    fi
  else
    printf '%s\n' "$(red 'MinIO ✗ stopped')" >&2
    printf '  %s\n' "$(dim 'Run: ohmydb setup')" >&2
  fi
}

cmd_open() {
  local name="${1:-}"

  # Subcommand-only flag: keep quick access to the GUI without picking a DB.
  if [[ "$name" == "--app" ]]; then
    if [[ ! -d "/Applications/TablePlus.app" ]]; then
      die "TablePlus not found. Install: brew install --cask tableplus"
    fi
    open -a TablePlus
    return 0
  fi

  if [[ ! -d "/Applications/TablePlus.app" ]]; then
    die "TablePlus not found. Install: brew install --cask tableplus"
  fi

  if [[ -n "$name" ]]; then
    pg_running || die "PostgreSQL is not running (try: ohmydb setup)"
    tableplus_open_pg "$name"
  else
    pg_running || die "PostgreSQL is not running (try: ohmydb setup)"
    name="$(choose_db_interactive "ohmydb open")" || exit 0
    tableplus_open_pg "$name"
  fi
}

cmd_psql() {
  local name
  name="$(resolve_name "${1:-}")"
  shift 2>/dev/null || true

  # Consume -- separator if present
  [[ "${1:-}" == "--" ]] && shift

  pg_running || die "PostgreSQL is not running"

  if command -v pgcli >/dev/null 2>&1; then
    exec pgcli -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d "$name" "$@"
  else
    exec psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d "$name" "$@"
  fi
}

cmd_setup() {
  if ! command -v brew >/dev/null 2>&1; then
    die "Homebrew is required"
  fi

  # PostgreSQL
  if brew list postgresql@17 >/dev/null 2>&1; then
    info "postgresql@17 installed"
  else
    printf '%s\n' "$(dim 'Installing postgresql@17...')" >&2
    brew install postgresql@17
    info "postgresql@17 installed"
  fi

  # Redis
  if brew list redis >/dev/null 2>&1; then
    info "redis installed"
  else
    printf '%s\n' "$(dim 'Installing redis...')" >&2
    brew install redis
    info "redis installed"
  fi

  # MinIO
  if brew list minio >/dev/null 2>&1; then
    info "minio installed"
  else
    printf '%s\n' "$(dim 'Installing minio...')" >&2
    brew install minio
    info "minio installed"
  fi

  # MinIO client
  if brew list minio-mc >/dev/null 2>&1; then
    info "minio-mc installed"
  else
    printf '%s\n' "$(dim 'Installing minio-mc...')" >&2
    brew install minio-mc
    info "minio-mc installed"
  fi

  # Start services
  if pg_running; then
    info "postgresql@17 started"
  else
    brew services start postgresql@17
    info "postgresql@17 started"
  fi

  if redis_running; then
    info "redis started"
  else
    brew services start redis
    info "redis started"
  fi

  # MinIO: try brew service if present, otherwise start our own background process.
  if minio_running; then
    info "minio started"
  else
    brew services start minio >/dev/null 2>&1 || true
    minio_running || minio_start_local
    info "minio started"
  fi

  printf '\n  %s\n' "$(dim 'Ready! Try: ohmydb create myapp')" >&2
}

# --- Parse global flags ---
args=()
passthrough=0
extra_args=()

for arg in "$@"; do
  if [[ "$passthrough" -eq 1 ]]; then
    extra_args+=("$arg")
    continue
  fi
  case "$arg" in
    --)
      passthrough=1
      extra_args+=("$arg")
      ;;
    -h|--help)
      usage
      ;;
    --version)
      echo "$VERSION"
      exit 0
      ;;
    -j|--json)
      JSON=1
      ;;
    -f|--force)
      FORCE=1
      ;;
    --no-input)
      NO_INPUT=1
      ;;
    --no-color)
      USE_COLOR=0
      ;;
    *)
      args+=("$arg")
      ;;
  esac
done

# Reconstruct args with passthrough
set -- "${args[@]+"${args[@]}"}" "${extra_args[@]+"${extra_args[@]}"}"

# --- Dispatch ---
cmd="${1:-list}"
shift 2>/dev/null || true

case "$cmd" in
  create|c|new)   cmd_create "$@" ;;
  drop|rm)        cmd_drop "$@" ;;
  list|ls)        cmd_list "$@" ;;
  url|u)          cmd_url "$@" ;;
  env|e)          cmd_env "$@" ;;
  clone|cp)       cmd_clone "$@" ;;
  reset)          cmd_reset "$@" ;;
  redis|r)        cmd_redis "$@" ;;
  minio|m)        cmd_minio "$@" ;;
  info|i)         cmd_info "$@" ;;
  open|o)         cmd_open "$@" ;;
  psql|sh)        cmd_psql "$@" ;;
  setup)          cmd_setup "$@" ;;
  *)
    printf 'Unknown command: %s\n' "$cmd" >&2
    printf 'Run "ohmydb --help" for usage.\n' >&2
    exit 2
    ;;
esac
